using System;

namespace Unity.Sentis
{
    public static partial class Functional
    {
        /// <summary>
        /// Returns an output generated with values 0 and 1 from a Bernoulli distribution.
        /// </summary>
        /// <param name="input">The probabilities used for generating the output values.</param>
        /// <param name="dataType">The data type of the output.</param>
        /// <param name="seed">The optional seed value for the random number generator.</param>
        /// <returns>The output tensor.</returns>
        public static FunctionalTensor Bernoulli(FunctionalTensor input, DataType dataType = DataType.Int, int? seed = null)
        {
            var output = FromLayer(new Layers.Bernoulli(-1, -1, dataType, seed), dataType, input);
            if (input.isShapeKnown)
                output.SetShape(input.shape);
            return output;
        }

        /// <summary>
        /// Returns an output generated from the multinomial probability distribution in the corresponding row of the input.
        /// </summary>
        /// <param name="input">The probability distributions.</param>
        /// <param name="numSamples">The number of samples.</param>
        /// <param name="seed">The optional seed value for the random number generator.</param>
        /// <returns>The output tensor.</returns>
        public static FunctionalTensor Multinomial(FunctionalTensor input, int numSamples, int? seed = null)
        {
            // TODO add replacement arg
            input = input.Float();
            var output = FromLayer(new Layers.Multinomial(-1, -1, numSamples, seed), DataType.Int, input);
            if (input.isShapeKnown)
                output.SetShape(new TensorShape(input.shape[0], numSamples));
            return output;
        }

        /// <summary>
        /// Returns a randomly selected values from a 1D input tensor.
        /// </summary>
        /// <param name="input">The input tensor to select random values from.</param>
        /// <param name="size">The shape of the output tensor.</param>
        /// <param name="seed">The optional seed value for the random number generator.</param>
        /// <returns>The output tensor.</returns>
        public static FunctionalTensor RandomChoice(FunctionalTensor input, int[] size, int? seed = null)
        {
            DeclareRank(input, 1);
            var shape = new TensorShape(size);
            if (shape.HasZeroDims())
                return Zeros(size, input.dataType);
            var inputSize = FromLayer(new Layers.Size(-1, -1), DataType.Int, input);
            inputSize.SetShape(new TensorShape());
            var index = Int(Floor(inputSize * Rand(new[] { shape.length }, seed)));
            var output = Gather(input, 0, index).Reshape(size);
            output.SetShape(shape);
            return output;
        }

        /// <summary>
        /// Returns a randomly selected value from a 1D input tensor with probabilities given by the tensor p.
        /// </summary>
        /// <param name="input">The input tensor to select random values from.</param>
        /// <param name="size">The shape of the output tensor.</param>
        /// <param name="p">The probabilities tensor corresponding to the values.</param>
        /// <param name="seed">The optional seed value for the random number generator.</param>
        /// <returns>The output tensor.</returns>
        public static FunctionalTensor RandomChoice(FunctionalTensor input, int[] size, FunctionalTensor p, int? seed = null)
        {
            DeclareRank(input, 1);
            DeclareRank(p, 1);
            var shape = new TensorShape(size);
            if (shape.HasZeroDims())
                return Zeros(size, input.dataType);
            var index = Multinomial(p.Unsqueeze(0), shape.length, seed).Squeeze(new[] { 0 });
            var output = Gather(input, 0, index).Reshape(size);
            output.SetShape(shape);
            return output;
        }

        /// <summary>
        /// Returns an output generated by sampling a normal distribution.
        /// </summary>
        /// <param name="mean">The mean of the normal distribution.</param>
        /// <param name="std">The standard deviation of the normal distribution.</param>
        /// <param name="size">The shape of the output tensor.</param>
        /// <param name="seed">The optional seed value for the random number generator.</param>
        /// <returns>The output tensor.</returns>
        public static FunctionalTensor Normal(float mean, float std, int[] size, int? seed = null)
        {
            var output = FromLayer(new Layers.RandomNormal(-1, size, mean, std, seed), DataType.Float, Array.Empty<FunctionalTensor>());
            output.SetShape(new TensorShape(size));
            return output;
        }

        /// <summary>
        /// Returns an output generated by sampling a normal distribution with shape matching the input tensor.
        /// </summary>
        /// <param name="mean">The mean of the normal distribution.</param>
        /// <param name="std">The standard deviation of the normal distribution.</param>
        /// <param name="input">The input tensor.</param>
        /// <param name="seed">The optional seed value for the random number generator.</param>
        /// <returns>The output tensor.</returns>
        public static FunctionalTensor NormalLike(float mean, float std, FunctionalTensor input, int? seed = null)
        {
            var output = FromLayer(new Layers.RandomNormalLike(-1, -1, mean, std, seed), DataType.Float, input);
            if (input.isShapeKnown)
                output.SetShape(input.shape);
            return output;
        }

        /// <summary>
        /// Returns an output generated by sampling a uniform distribution on the interval [0, 1).
        /// </summary>
        /// <param name="size">The shape of the output tensor.</param>
        /// <param name="seed">The optional seed value for the random number generator.</param>
        /// <returns>The output tensor.</returns>
        public static FunctionalTensor Rand(int[] size, int? seed = null)
        {
            var output = FromLayer(new Layers.RandomUniform(-1, size, 0, 1, seed), DataType.Float, Array.Empty<FunctionalTensor>());
            output.SetShape(new TensorShape(size));
            return output;
        }

        /// <summary>
        /// Returns an output generated by sampling a uniform distribution on the interval [0, 1) with shape matching the input tensor.
        /// </summary>
        /// <param name="input">The input tensor.</param>
        /// <param name="seed">The optional seed value for the random number generator.</param>
        /// <returns>The output tensor.</returns>
        public static FunctionalTensor RandLike(FunctionalTensor input, int? seed = null)
        {
            var output = FromLayer(new Layers.RandomUniformLike(-1, -1, 0, 1, seed), DataType.Float, input);
            if (input.isShapeKnown)
                output.SetShape(input.shape);
            return output;
        }

        /// <summary>
        /// Returns an output generated by sampling a uniform distribution of integers on the interval [low, high).
        /// </summary>
        /// <param name="size">The shape of the output tensor.</param>
        /// <param name="low">The inclusive minimum value of the interval.</param>
        /// <param name="high">The exclusive maximum value of the interval.</param>
        /// <param name="seed">The optional seed value for the random number generator.</param>
        /// <returns>The output tensor.</returns>
        public static FunctionalTensor RandInt(int[] size, int low, int high, int? seed = null)
        {
            var output = Floor(FromLayer(new Layers.RandomUniform(-1, size, low, high, seed), DataType.Float, Array.Empty<FunctionalTensor>())).Int();
            output.SetShape(new TensorShape(size));
            return output;
        }

        /// <summary>
        /// Returns an output generated by sampling a uniform distribution of integers on the interval [low, high) with shape matching the input tensor.
        /// </summary>
        /// <param name="input">The input tensor.</param>
        /// <param name="low">The inclusive minimum value of the interval.</param>
        /// <param name="high">The exclusive maximum value of the interval.</param>
        /// <param name="seed">The optional seed value for the random number generator.</param>
        /// <returns>The output tensor.</returns>
        public static FunctionalTensor RandIntLike(FunctionalTensor input, int low, int high, int? seed = null)
        {
            var output = Floor(FromLayer(new Layers.RandomUniformLike(-1, -1, low, high, seed), DataType.Float, input)).Int();
            if (input.isShapeKnown)
                output.SetShape(input.shape);
            return output;
        }

        /// <summary>
        /// Returns an output generated by sampling a standard normal distribution.
        /// </summary>
        /// <param name="size">The shape of the output tensor.</param>
        /// <param name="seed">The optional seed value for the random number generator.</param>
        /// <returns>The output tensor.</returns>
        public static FunctionalTensor RandN(int[] size, int? seed = null)
        {
            var output = FromLayer(new Layers.RandomNormal(-1, size, 0, 1, seed), DataType.Float, Array.Empty<FunctionalTensor>());
            output.SetShape(new TensorShape(size));
            return output;
        }

        /// <summary>
        /// Returns an output generated by sampling a standard normal distribution with shape matching the input tensor.
        /// </summary>
        /// <param name="input">The input tensor.</param>
        /// <param name="seed">The optional seed value for the random number generator.</param>
        /// <returns>The output tensor.</returns>
        public static FunctionalTensor RandNLike(FunctionalTensor input, int? seed = null)
        {
            var output = FromLayer(new Layers.RandomNormalLike(-1, -1, 0, 1, seed), DataType.Float, input);
            if (input.isShapeKnown)
                output.SetShape(input.shape);
            return output;
        }
    }
}
